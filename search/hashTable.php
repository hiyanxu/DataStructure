<?php
/*
 * 散列表：
 *  散列表是利用数组支持按照下标随机访问数据的特性，通过key找到存储散列数据的数组下标（即hash(key) = "散列数组下标"），进而得到散列数据
 *  
 * 散列表的关键：散列函数、散列冲突解决
 * 
 * 散列函数设计要求：
 * （1）散列函数计算得到的散列值是一个非负整数。
 * （2）若key1=key2，则hash(key1) == hash(key2)。
 * （3）若key1 != key2，则hash(key1) != hash(key2)。
 * 几乎无法找到一个完美的hash函数，保证不会出现哈希冲突（因为数据的存储空间有限，当散列空间越来越小时，出现冲突的概率将大大增加）。
 * 
 * 散列冲突解决：
 * （1）开放寻址法：
 *      a、线性探测：
 *          数据插入：当hash后，发现对应下标下已存在数据，则沿着下标往下寻找，直到找到一个空闲位置，将该数据存放在该下标位置上。
 *          数据查找：类似于插入过程，当hash后获取下标，判断该下标元素是否是要查找的元素，若是，则直接返回；若不是，则顺序往后查找，直到找到该数据或查找到空闲位置处，表示该数据没在该散列表中。
 *          数据删除：查找到该数据，然后删除，将该下标位置置为“deleted”（这是因为防止出现查找时查找到空位置，其实该位置是被删除数据，该位置后面还存在数据）。
 *          时间复杂度：因为最坏情况需要往后查找整个列表的长度，则最坏时间复杂度为O(n)，最好为O(1)。    
 *      
 *      b、链表法：
 *          链表法中，散列数据的每个下标不再存储数据，而是存储指向一个链表的指针，链表中存放散列数据，这样，所有的操作其实是对链表的操作了。
 *          时间复杂度：时间复杂度跟需要遍历的链表的长度有关。     
 * */